/*

Сортування вибором — це простий алгоритм сортування лінійного масиву, який базується на основі вставок.

Він має ефективність n^2, що робить його неефективним при сортуванні великих масивів, і менш ефективним за подібний алгоритм сортування включенням.

Сортування вибором відрізняється більшою простотою, ніж сортування включенням, і в деяких випадках, вищою продуктивністю.

Алгоритм працює таким чином:

1. Знаходить у списку найменше значення;
2. Міняє його місцями з першим значенням у списку;
3. Повторює два попередніх кроки, доки список не завершиться (починаючи з наступної позиції).

Фактично, таким чином ми поділили список на дві частини: перша (ліва) — повністю відсортована, а друга (права) — ні.

З таким методом ознайомилися, зараз саме час перевірити його в дії. Спробуємо зробити сорування вибором мовою C++.

*/

#include <iostream>
#include <string>
using namespace std;

void selectSort(string a[], long size) //  selectSort - сортування вибором
{
    long i, j, k; // тип змінних - довгий
    string x;

    for (i = 0; i < size; i++) // i - номер поточного кроку
    {
        k = i; // k - індекс найменшого елементу 
        x = a[i];

        // цикл вибору найменшого елементу

        for (j = i + 1; j < size; j++) 
            if (a[j] < x) 
            {
                k = j; x = a[j]; 
            }

        // змінюємо місцями найменший елемент з "a[i]"

        a[k] = a[i];
        a[i] = x;
    }
}

void main()
{
    setlocale(LC_ALL, "Ukr");
    int n, X = 25, P = 73;

    cout << "Введ*ть n: "; 
    cin >> n;

    string* s = new string[n];

    for (int i = 0; i < n; i++)
    {
        cout << i + 1 << ": "; 
        cin >> s[i];
    }

    selectSort(s, n);

    for (int i = 0; i < n; i++)
    {
        cout << s[i] << endl;
    }

    cout << endl; 
    system("pause");
}

/*

Висновок: отже, виконання пройшло успішно, метод перевірено, можна сказати,

що цей метод досить ефективний для сортування масивів, оскільки від інших

методів відрізняється своєю простотою (програма невелика) та ефективністю для малих масивів.

В цілому, якщо не враховувати пробіли, коментарі та змінні, то вийшло 17 командних рядків, що задовольняє умові: 

проаналізувати будь-який програмний код (приблизно 15-20 команд, не враховуючу команди оголошення змінних)

*/